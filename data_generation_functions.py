# -*- coding: utf-8 -*-

import logging
import numpy as np
from numba import njit

#%% logging the parameters of the data generation
class data_generation_logger:
    """logger with name "data_generation_logger"
    """
    def create(filepath):
        logging.basicConfig(level=logging.INFO)
        data_generation_logger.fh = logging.FileHandler(filepath,mode="w")
        data_generation_logger.logger = logging.getLogger("data_generation_logger")
        data_generation_logger.logger.addHandler(data_generation_logger.fh)
        return data_generation_logger.logger
        
    def close():
        data_generation_logger.logger.removeHandler(data_generation_logger.fh)
        logging.shutdown()

        
def _logg_gen_correlate(beta0,beta1,epsilon):
    logger = logging.getLogger("data_generation_logger")
    logvars=[]
    logvars.append("beta0 = "+str(beta0))
    if hasattr(beta1, "__len__"):
        logstring="Y  = beta0"
        if not isinstance(epsilon, np.ndarray):
            standard=True
        for i in range(len(beta1)):
            logvars.append("beta"+str(i+1)+" = "+str(beta1[i]))
            logstring+=" + beta"+str(i+1)+"*X"+str(i+1)
        if standard:
            logvars.append("epsilon = normal_distribution( mu = 0 , sigma = "+str(epsilon)+" )")
        logstring+=" + epsilon"
    else:    
        logstring="Y  = beta0 + beta1*X + epsilon"
        logvars.append("beta1 = "+str(beta1))
        if not isinstance(epsilon, np.ndarray):
            logvars.append("epsilon = normal_distribution( mu = 0 , sigma = "+str(epsilon)+" )")
    
    logger.info("    " +logstring)
    for i in logvars:
        logger.info("    " +i)
    logger.info("")


def _logg_gen_moderate(beta0,beta1,beta2,beta3,epsilon):
    logger = logging.getLogger("data_generation_logger")
    logstring="Y  = beta0 + beta1*X1 + beta2*X2 + beta3*X1*X2 + epsilon"
    logvars=["beta0 = "+str(beta0)]
    logvars.append("beta1 = "+str(beta1))
    logvars.append("beta2 = "+str(beta2))
    logvars.append("beta3 = "+str(beta3))

    if not isinstance(epsilon, np.ndarray):
        logvars.append("epsilon = normal_distribution( mu = 0 , sigma = "+str(epsilon)+" )")

    logger.info("    " +logstring)
    for i in logvars:
        logger.info("    " +i)
    logger.info("")
    
def _logg_normal_dist(mu,sigma):
    logger = logging.getLogger("data_generation_logger")
    logger.info("generated by a normal distribution with mean mu and standard deviation sigma")
    logger.info("    mu = "+str(mu))
    logger.info("    sigma = "+str(sigma))
    logger.info("")


#%% generate random distribution variables with interdependence

def z_transform(X):
    return (X-np.mean(X))/np.std(X)

def gen_correlate(X,beta0,beta1,epsilon,create_log=True):
    if create_log:
        _logg_gen_correlate(beta0, beta1, epsilon)
    
    if hasattr(beta1, "__len__"):
        if not isinstance(epsilon, np.ndarray):
            epsilon=np.random.normal(0,epsilon,len(X[0]))
        
        Y=np.zeros(len(X[0]))+beta0
        for i in range(len(beta1)):
            Y+= beta1[i]*X[i]
    else:
        if not isinstance(epsilon, np.ndarray):
            epsilon=np.random.normal(0,epsilon,len(X))
        
        Y=beta0+beta1*X

    return Y+epsilon


def gen_moderate(X1,X2,beta0,beta1,beta2,beta3,epsilon,create_log=True):
    if create_log:
        _logg_gen_moderate(beta0, beta1,beta2,beta3, epsilon)
    if not isinstance(epsilon, np.ndarray):
        epsilon=np.random.normal(0,epsilon,len(X1))

    return beta0+beta1*X1+beta2*X2+beta3*X1*X2+epsilon

def normal_dist(mu,sigma,N,create_log=True):
    if create_log:
        _logg_normal_dist(mu, sigma)
    return np.random.normal(mu,sigma,N)


#%% pairwise group merging
@njit
def _shiftroll(shift,N):
    res=[]
    switch=True
    for i in range(N):
        if switch:
            res.append(i)
        if (i+1)%shift==0:
            switch= not switch
    return res


def propose_group_merges(keylist,shift=1,first=True):
    
    pattern=np.array(_shiftroll(shift,len(keylist)),dtype=int)
    if not first:
        ending_crop=len(keylist)-len(pattern)
        pattern= (pattern+shift)[:ending_crop]

    orig=keylist[pattern]
    rolled=keylist[(pattern+shift)%len(keylist)]
    merges=[i for i in zip(orig,rolled)]
    return np.array(merges)


def check_and_execute_merge(merges,groups,props,ratio):
    counter=0    
    for i in merges:
        first=i[0]
        second=i[1]
        group_members=groups[first]["members"]+groups[second]["members"]
        
        groupordering=np.argsort(-props[group_members],axis=0).T
        groupthresh=int(ratio*len(group_members)+1)
        best=groupordering[:,:groupthresh]
        merge_cond=True
        for j in range(len(group_members)):
            if j not in best:
                merge_cond=False 
                break
        
        #merge_cond=True ## for testing only ############################
        if merge_cond:
            counter +=1
            groups[first]["members"]=group_members
            del groups[second]
    
    return groups,counter

